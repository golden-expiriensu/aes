use std::ops::BitXor;

use crate::{key::Key, sbox, Block};

pub fn encrypt<'a, const L: usize>(block: Block, key: Key<L>) -> Vec<u8> {
    let n_rounds = key.n_rounds();
    let round_keys = key.expand();
    let mut block = round_keys[0].xor(block);

    for i in 1..n_rounds {
        block = round_keys[i].xor(mix_columns(shift_rows(block.map(sbox::sub_byte))));
    }
    // Last round without mix_columns.
    round_keys[n_rounds]
        .xor(shift_rows(block.map(sbox::sub_byte)))
        .into()
}

fn shift_rows(block: Block) -> Block {
    // Convert column major to row major matrix.
    let mut block = block.transposed();
    for (i, row) in block.rows_mut().enumerate() {
        row.rotate_left(i);
    }
    // Convert back to column major matrix.
    block.transposed()
}

fn mix_columns(block: Block) -> Block {
    // Galois Field (256) multiplication of two bytes.
    let mul_fn = |(mut a, mut b): (u8, u8)| -> u8 {
        let mut p = 0;

        for _ in 0..8 {
            if (b & 1) != 0 {
                p ^= a;
            }

            let hi_bit_set = (a & 0x80) != 0;
            a <<= 1;
            if hi_bit_set {
                a ^= 0x1B; /* x^8 + x^4 + x^3 + x + 1 */
            }
            b >>= 1;
        }

        return p;
    };

    block.mul(
        [[2, 1, 1, 3], [3, 2, 1, 1], [1, 3, 2, 1], [1, 1, 3, 2]].into(),
        mul_fn,
        BitXor::bitxor,
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shift_rows() {
        let before = [
            0x6e, 0xb6, 0x51, 0x4d, 0xd1, 0x77, 0x84, 0x39, 0x7d, 0xbc, 0x5a, 0x4c, 0x26, 0x43,
            0x77, 0xc7,
        ];
        let after = shift_rows(before.try_into().unwrap());

        let expected = [
            0x6e, 0x77, 0x5a, 0xc7, 0xd1, 0xbc, 0x77, 0x4d, 0x7d, 0x43, 0x51, 0x39, 0x26, 0xb6,
            0x84, 0x4c,
        ];
        assert_eq!(Block::try_from(expected).unwrap(), after);
    }

    #[test]
    fn test_mix_columns() {
        let before = [
            0x6e, 0x77, 0x5a, 0xc7, 0xd1, 0xbc, 0x77, 0x4d, 0x7d, 0x43, 0x51, 0x39, 0x26, 0xb6,
            0x84, 0x4c,
        ];
        let after = mix_columns(before.try_into().unwrap());

        let expected = [
            0xd8, 0xa9, 0xff, 0x0a, 0x5c, 0x66, 0x54, 0x39, 0x57, 0x31, 0xd7, 0xe7, 0x45, 0x8a,
            0x57, 0xc0,
        ];
        assert_eq!(Block::try_from(expected).unwrap(), after);
    }

    #[test]
    fn test_encrypt_128() {
        let data = [
            0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33, 0x33, 0x44, 0x44,
            0x44, 0x44,
        ];
        let key = [
            0x54, 0x68, 0x61, 0x74, 0x73, 0x20, 0x6d, 0x79, 0x20, 0x4b, 0x75, 0x6e, 0x67, 0x20,
            0x46, 0x75,
        ];
        let expected = [
            0xe3, 0x79, 0x9b, 0xc1, 0xcb, 0x4e, 0x5f, 0xb8, 0xea, 0xa6, 0x4b, 0xec, 0x0c, 0x43,
            0xb2, 0xdf,
        ];
        assert_eq!(encrypt(data.try_into().unwrap(), Key::new(key)), &expected);
    }

    #[test]
    fn test_encrypt_192() {
        let data = [
            0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33, 0x33, 0x44, 0x44,
            0x44, 0x44,
        ];
        let key = [
            0x54, 0x68, 0x61, 0x74, 0x73, 0x20, 0x6d, 0x79, 0x20, 0x4b, 0x75, 0x6e, 0x67, 0x20,
            0x46, 0x75, 0x54, 0x68, 0x61, 0x74, 0x73, 0x20, 0x6d, 0x79,
        ];
        let expected = [
            0xb9, 0x87, 0x8e, 0x59, 0x6c, 0x50, 0xc6, 0x83, 0x5b, 0xee, 0x86, 0x71, 0xe2, 0xa8,
            0x82, 0x82,
        ];
        assert_eq!(encrypt(data.try_into().unwrap(), Key::new(key)), &expected);
    }

    #[test]
    fn test_encrypt_256() {
        let data = [
            0x11, 0x11, 0x11, 0x11, 0x22, 0x22, 0x22, 0x22, 0x33, 0x33, 0x33, 0x33, 0x44, 0x44,
            0x44, 0x44,
        ];
        let key = [
            0x54, 0x68, 0x61, 0x74, 0x73, 0x20, 0x6d, 0x79, 0x20, 0x4b, 0x75, 0x6e, 0x67, 0x20,
            0x46, 0x75, 0x54, 0x68, 0x61, 0x74, 0x73, 0x20, 0x6d, 0x79, 0x20, 0x4b, 0x75, 0x6e,
            0x67, 0x20, 0x46, 0x75,
        ];
        let expected = [
            0x07, 0xa5, 0xaf, 0xcb, 0xa0, 0x60, 0xb2, 0x77, 0xde, 0xd0, 0x7c, 0x17, 0x1a, 0x70,
            0x38, 0x81,
        ];
        assert_eq!(encrypt(data.try_into().unwrap(), Key::new(key)), &expected);
    }
}
